using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Windows.Forms;
using Point = System.Drawing.Point;

namespace Chummer.Backend.Options
{
    /*
     * This class contains the logic used (at time of writing) for basic layout of (everything) when autogenerating
     * interfaces. (Only used by options at time of writing). This contains the layouting part of autogenerated interfaces.
     * It cooperates with OptionRender.cs to do the actual rendering (well, adding stuff to a control)
     * I'm not very versed in WPF, but it _should_ work with anything with uniform text size.
     *
     * It is named as so, because it provides layout, it uses tab to align stuff and thats it. Anybody feel free to refactor to a better name.
     * As it is still under development, it contains quite a few debug statements. Those _should_ be removed before release
     */
    public class TabAlignmentGroupLayoutProvider : IGroupLayoutProvider
    {
        private class UserLine
        {
            public List<DisplayBlock> DisplayBlocks { get; } = new List<DisplayBlock>() {new DisplayBlock()};
        }

        private class DisplayBlock
        {
            public List<TextOrControl> AtomicParts { get; } = new List<TextOrControl>();
        }

        private class TabLayoutGroupComputation : LayoutGroupComputation
        {
            public List<UserLine> UserLines { get; }
            public List<int> MaxSizeOfBlockAtIndex { get; }
            public Dictionary<string, RectangleF> StringPieces { get; }

            public TabLayoutGroupComputation(List<UserLine> userLines, List<int> maxSizeOfBlockAtIndex, Dictionary<string, RectangleF> stringPieces)
            {
                UserLines = userLines;
                MaxSizeOfBlockAtIndex = maxSizeOfBlockAtIndex;
                StringPieces = stringPieces;
            }
        }

        //TODO: This is a sum type and should use some shared implementation, but im not aware of any implementation that is available atm
        [DebuggerDisplay("{(IsControl ? \"Control\" : _text)}")]
        private class TextOrControl
        {
            /// <summary>
            /// If this is set, a tooltip has been active over every item before it and on this one. 
            /// </summary>
            public string EndOfToolTipHere { get; set; }
            public bool IsControl { get; }
            private Rectangle _control;
            private string _text;

            public Rectangle Control
            {
                get
                {
                    if (IsControl) return _control;
                    throw new InvalidOperationException();
                }
            }

            public string Text
            {
                get
                {
                    if (!IsControl) return _text;
                    throw new InvalidOperationException();
                }
            }

            public TextOrControl(Rectangle sizeOfControl)
            {
                IsControl = true;
                _control = sizeOfControl;
            }

            public TextOrControl(string text)
            {
                IsControl = false;
                _text = text;
            }
        }

        private readonly string[] _split = { "\\t" };
        public LayoutGroupComputation ComputeLayoutGroup(Graphics willBeRenderedOn, List<LayoutLineInfo> contents, ref object crossGroupSharedData)
        {
            //Input (contents) is organized in lines. In most cases we are also working on lines, but not always, and even then, different lines. 
            //First step is to convert it to lines user sees, composed of displayblocks, itself composed of text and controls

            //All strings we have seen (and will render)
            HashSet<string> stringPieces = new HashSet<string>();
            //List of all lines
            List<UserLine> userLines = new List<UserLine>(contents.Count);
            //Current working line
            UserLine currentUserLine = new UserLine();

            foreach (LayoutLineInfo layoutLine in contents)
            {

                string layoutString = layoutLine.LayoutString;

                //below should never run, but prevents bad things happening if layoutLine has multiple {} in it
                if (layoutString.IndexOf("{}", StringComparison.Ordinal) != layoutString.LastIndexOf("{}", StringComparison.Ordinal))
                {
                    Utils.BreakIfDebug();
                    string[] parts = layoutString.Split(new[] {"{}"}, StringSplitOptions.None);

                    layoutString = parts[0] + "{}" + string.Join(null, parts.Skip(1));

                }

                //HI THERE: IF YOUR STRING GETS INTERPRENTED WRONG THIS IS MOST LIKELY YOUR GOAT. IT IS PRIMITIVE!
                string[] alignmentPieces = layoutString.TrimEnd('\\').Split(_split, StringSplitOptions.None);


                //Go over every text piece. Those will all be converted to displayBlocks
                for (int index = 0; index < alignmentPieces.Length; index++)
                {
                    string alignmentPiece = alignmentPieces[index];
                    int indexOfControl = alignmentPiece.IndexOf("{}", StringComparison.Ordinal);

                    //If the displayblock contains one {} it has a control.
                    //But it might also just be a piece of text
                    //If it contains a {}, the displayBlock should have the text in front and back(if any) added
                    //Otherwise just the text

                    //We are not creating the displayBlock here as it can come from a few things. One is implicit part of the UserLine, and we create a new one _ONLY_ if we move to the next
                    //This allows us to do weird shit like glue lines together to create fancy single line options
                    //TODO: EDGE CASE?: NO TEXT
                     
                    if (indexOfControl != -1)
                    {
                        //This would be a good candidate for code to extract and unit test

                        //if {} is in front, don't add leading text
                        if (indexOfControl != 0)
                        {
                            string str = alignmentPiece.Substring(0, indexOfControl);
                            stringPieces.Add(str);
                            currentUserLine.DisplayBlocks.Last()
                                .AtomicParts.Add(new TextOrControl(str));
                        }

                        //Add control in place of {}
                        currentUserLine.DisplayBlocks.Last().AtomicParts.Add(new TextOrControl(layoutLine.ControlRectangle));

                        //if {} is in back, don't add trailing text
                        if (indexOfControl != alignmentPiece.Length - 2)
                        {
                            string str = alignmentPiece.Substring(indexOfControl + 2);
                            stringPieces.Add(str);
                            currentUserLine.DisplayBlocks.Last()
                                .AtomicParts.Add(new TextOrControl(str));
                        }
                        
                    }
                    else
                    {
                        stringPieces.Add(alignmentPiece);
                        currentUserLine.DisplayBlocks.Last().AtomicParts.Add(new TextOrControl(alignmentPiece));
                    }

                    //If this was not the last DisplayBlock, add a new displayBlock
                    if (index != alignmentPieces.Length - 1)
                    {
                        currentUserLine.DisplayBlocks.Add(new DisplayBlock());
                    }
                }

                currentUserLine.DisplayBlocks.Last().AtomicParts.Last().EndOfToolTipHere = layoutLine.ToolTip;

                //Normaly we start a new line, but if string ends with \ we glue the next line on here
                if (!layoutLine.LayoutString.EndsWith("\\"))
                {
                    userLines.Add(currentUserLine);
                    currentUserLine = new UserLine();
                }
            }

            //We now have a load of lines. Goal is now to compute how large text on said lines is.

            //First step is to measure the size of all text
            Dictionary<string, RectangleF> textSizes = ComputeTextSize(willBeRenderedOn, stringPieces.ToList());


            //We can now compute how big each displayblock is. Do this, and compute the size of the largest first block, second block, ect is
            //To ensure consistency over multiple groups, save it in crossGroupSharedData
            List<int> maxSizeOfBlockAtIndex = crossGroupSharedData as List<int> ?? new List<int>();

            foreach (UserLine line in userLines)
            {
                for (int i = 0; i < line.DisplayBlocks.Count; i++)
                {
                    int sizeOfDispayBlock = ComputeSizeOfDisplayBlock(textSizes, line.DisplayBlocks[i]);


                    if (maxSizeOfBlockAtIndex.Count > i)
                    {
                        maxSizeOfBlockAtIndex[i] = Math.Max(maxSizeOfBlockAtIndex[i], sizeOfDispayBlock);
                    }
                    else
                    {
                        maxSizeOfBlockAtIndex.Add(sizeOfDispayBlock);
                    }
                }
            }

            crossGroupSharedData = maxSizeOfBlockAtIndex;

            return new TabLayoutGroupComputation(userLines, maxSizeOfBlockAtIndex, textSizes);
        }

        public RenderedLayoutGroup RenderLayoutGroup(Graphics willBeRenderedOn, LayoutGroupComputation preComputedLayoutGroup,
            object crossGroupSharedData = null)
        {
            TabLayoutGroupComputation preComputed = preComputedLayoutGroup as TabLayoutGroupComputation;
            if(preComputed == null) throw new ArgumentException("preComputedLayoutGroup needs to have been provided by the same IGroupLayoutProvider and not be null");


            //Currently only tracking how big each displayBlock is. Now compute where each displayBlock will start
            int usedSize = 0;
            List<int> displayBlockStartAt = new List<int>(preComputed.MaxSizeOfBlockAtIndex.Count);
            foreach (int blockSize in preComputed.MaxSizeOfBlockAtIndex)
            {
                displayBlockStartAt.Add(usedSize);
                usedSize += blockSize;
            }

            List<Point> controlLocations = new List<Point>();
            List<RenderedLayoutGroup.TextRenderInfo> textLocations = new List<RenderedLayoutGroup.TextRenderInfo>();
            List<RenderedLayoutGroup.ToolTipData> toolTips = new List<RenderedLayoutGroup.ToolTipData>();

            int nextLineBeginsAt = 0;
            int toolTipBeginsAt = 0;
            foreach (UserLine userLine in preComputed.UserLines)
            {
                //if (userLine.DisplayBlocks.SelectMany(x => x.AtomicParts).Count(x => x.IsControl) > 1)
                //    Debugger.Break();
                
                int lineBottom = nextLineBeginsAt;
                for (int index = 0; index < userLine.DisplayBlocks.Count; index++)
                {
                    DisplayBlock displayBlock = userLine.DisplayBlocks[index];
                    int elementStartingPoint = displayBlockStartAt[index];
                    
                    foreach (TextOrControl textOrControl in displayBlock.AtomicParts)
                    {
                        if (textOrControl.IsControl)
                        {
                            Rectangle objPartRectangle = textOrControl.Control;
                            controlLocations.Add(
                                new Point(
                                    objPartRectangle.X + elementStartingPoint + LayoutOptions.ControlMargin,
                                    objPartRectangle.Y + nextLineBeginsAt));  //TODO: This line probably lacks something, controls could once move up or down a little
                            elementStartingPoint += LayoutOptions.ControlMargin + objPartRectangle.Width;

                            lineBottom = Math.Max(lineBottom, nextLineBeginsAt + objPartRectangle.Height);
                        }
                        else
                        {
                            var size = ToSize(preComputed.StringPieces[textOrControl.Text]);
                            textLocations.Add(new RenderedLayoutGroup.TextRenderInfo
                            {
                                Text = textOrControl.Text,
                                Size = size,
                                Location = new Point(elementStartingPoint, nextLineBeginsAt),
                                Style = FontStyle.Regular //TODO: Does this get used? Do i want to support it?
                            });

                            elementStartingPoint += size.Width;
                            lineBottom = Math.Max(lineBottom, nextLineBeginsAt + size.Height);
                        }

                        if (textOrControl.EndOfToolTipHere != null)
                        {
                            toolTips.Add(
                                new RenderedLayoutGroup.ToolTipData(
                                    textOrControl.EndOfToolTipHere,
                                    new Rectangle(
                                        toolTipBeginsAt, 
                                        nextLineBeginsAt, 
                                        elementStartingPoint - toolTipBeginsAt,
                                        lineBottom - nextLineBeginsAt)));
                        }
                    }
                }

                nextLineBeginsAt = lineBottom + LayoutOptions.Linespacing;
            }
            

            return new RenderedLayoutGroup()
            {
                ControlLocations = controlLocations,
                TextLocations = textLocations,
                ToolTips = toolTips,
                Width = usedSize,
                Height = nextLineBeginsAt,
            }; 
        }

        //The graphics object will at max accept a batchsize of 32 or it will crap itself
        private const int BATCH_SIZE = 32;
        Dictionary<string, RectangleF> ComputeTextSize(Graphics graphics, List<string> lines)
        {
            //TODO: Might be able to make this global, and this part is slowish
            //Compute text size of every line
            //It might be possible to do this in a better(faster while still accurate) way, but we ask the Graphics object how large strings will be

            //Only hazzle is the Graphics object is slow.
            //We try to do it faster by batching (Nobody actually measured if batching is faster....)
            //But the graphics object will at max accept a batchsize of 32 or it will crap itself

            //So the following code is just an elaborate way of calling Graphics.MeasureText in big chunks
            int intLineCount = lines.Count;
            Dictionary<string, RectangleF> resultDictionary = new Dictionary<string, RectangleF>(intLineCount);
            CharacterRange[] ranges = new CharacterRange[Math.Min(BATCH_SIZE, intLineCount)];
            var format = new StringFormat();

            for (int start = 0; start < intLineCount; start += BATCH_SIZE)
            {
                int end = Math.Min(intLineCount, start + BATCH_SIZE);

                //Optimization, compute lenght of strings that will be added
                StringBuilder combinedText = new StringBuilder();

                for (int i = start; i < end; i++)
                {
                    string line = lines[i];
                    ranges[i-start] = new CharacterRange(combinedText.Length, line.Length);
                    combinedText.AppendLine(line);
                }
                combinedText.Length--; //Remove last newline

                // The last batch of a set may be smaller than 32, in which case we need to return a smaller array than the one we've been using
                int intRangeSize = end - start;
                if (intRangeSize < ranges.Length)
                {
                    CharacterRange[] objLastRanges = new CharacterRange[intRangeSize];
                    for (int i = 0; i < intRangeSize; i++)
                    {
                        objLastRanges[i] = ranges[i];
                    }
                    format.SetMeasurableCharacterRanges(objLastRanges);
                }
                else
                    format.SetMeasurableCharacterRanges(ranges);
                Region[] regions = graphics.MeasureCharacterRanges(
                    combinedText.ToString(), 
                    LayoutOptions.Font,
                    new RectangleF(0, 0, float.MaxValue, float.MaxValue), 
                    format);

                for (int i = start; i < end; i++)
                {
                    string line = lines[i];
                    Region region = regions[i - start];
                    resultDictionary.Add(line, region.GetBounds(graphics));
                }
            }

            return resultDictionary;
        }

        int ComputeSizeOfDisplayBlock(Dictionary<string, RectangleF> testSizes, DisplayBlock displayBlock)
        {
            int sizeSoFar = 0;
            foreach (TextOrControl atomicPart in displayBlock.AtomicParts)
            {
                if (atomicPart.IsControl)
                {
                    sizeSoFar += atomicPart.Control.Width + (LayoutOptions.ControlMargin*2);
                }
                else
                {
                    sizeSoFar += (int) Math.Ceiling(testSizes[atomicPart.Text].Width);
                }
            }
            return sizeSoFar;
        }

        //The layout procedure is rather simple (in theory).  It interprents multiple \t inside text and makes sure every
        //tab accros multiple lines share same end
        //Basically the same as normal text tab, but instead of having a defined lenght in spaces, it findes
        //the minimum possible accross all, without exeeding it
        //In other words, after every \t the next following character will align on all lines

        /// <summary>
        /// Various tweakable settings that can be changed
        /// </summary>
        public LayoutOptionsContainer LayoutOptions { get; set; } = new LayoutOptionsContainer();

        private static Size ToSize(RectangleF getBounds)
        {
            //Console.WriteLine("Rectangle of {0} {1}", getBounds.Width, getBounds.Height);
            return new Size((int) getBounds.Width, (int) getBounds.Height);
        }
    }
}