using NLog;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Point = System.Drawing.Point;

namespace Chummer.Backend.Options
{
    /*
     * This class contains the logic used (at time of writing) for basic layout of (everything) when autogenerating
     * interfaces. (Only used by options at time of writing). This contains the layouting part of autogenerated interfaces.
     * It cooperates with OptionRender.cs to do the actual rendering (well, adding stuff to a control)
     * I'm not very versed in WPF, but it _should_ work with anything with uniform text size.
     *
     * It is named as so, because it provides layout, it uses tab to align stuff and thats it. Anybody feel free to refactor to a better name.
     *
     * The layouting it performs is fairly simple conceptually. Every LayoutEntry is a string with exactly one special "character" "{}" which is a gui element
     * Other than having an iteresting and varying size, its treated as any other character. 
     * 
     * Then the text is tabulated, so that every tab ends the same place.
     * This is then made slightly more complex by supporting not having linefeeds but gluing multiple LayoutEntries together on a single line.
     */
    public class TabAlignmentGroupLayoutProvider<LayoutEntry> : IGroupLayoutProvider<LayoutEntry> where LayoutEntry : ILayoutEntry
    {
        private Logger Log = NLog.LogManager.GetCurrentClassLogger();
        private class UserLine
        {
            public List<DisplayBlock> DisplayBlocks { get; } = new List<DisplayBlock>();
        }

        private class DisplayBlock
        {
            public List<TextOrControl> AtomicParts { get; } = new List<TextOrControl>();

            public DisplayBlock(List<TextOrControl> atomicParts)
            {
                AtomicParts = atomicParts;
            }
        }

        private class TabLayoutGroupComputation : LayoutGroupComputation
        {
            public List<UserLine> UserLines { get; }
            public List<int> MaxSizeOfBlockAtIndex { get; }
            public Dictionary<string, RectangleF> StringPieces { get; }

            public TabLayoutGroupComputation(List<UserLine> userLines, List<int> maxSizeOfBlockAtIndex, Dictionary<string, RectangleF> stringPieces)
            {
                UserLines = userLines;
                MaxSizeOfBlockAtIndex = maxSizeOfBlockAtIndex;
                StringPieces = stringPieces;
            }
        }

        //TODO: This is a sum type and should use some shared implementation, but im not aware of any implementation that is available atm
        [DebuggerDisplay("{(IsControl ? \"Control\" : _text)}")]
        private class TextOrControl
        {
            /// <summary>
            /// If this is set, a tooltip has been active over every item before it and on this one. 
            /// </summary>
            public string EndOfToolTipHere { get; set; }
            public bool IsControl { get; }
            private Rectangle _control;
            private string _text;

            
            public LayoutEntry OriginDisplayLine { get; }

            public Rectangle Control
            {
                get
                {
                    if (IsControl) return _control;
                    throw new InvalidOperationException();
                }
            }

            public string Text
            {
                get
                {
                    if (!IsControl) return _text;
                    throw new InvalidOperationException();
                }
            }

            public TextOrControl(Rectangle sizeOfControl, LayoutEntry origin)
            {
                IsControl = true;
                _control = sizeOfControl;
                OriginDisplayLine = origin;
            }

            public TextOrControl(string text, LayoutEntry origin)
            {
                IsControl = false;
                _text = text;
                OriginDisplayLine = origin;
            }
        }

        private static Regex layoutStringTokenizer = new Regex("({})|(?://)|(?:\\\\\\\\)", RegexOptions.Compiled);

        private readonly string[] _split = { "\\t", "\t" };
        public LayoutGroupComputation ComputeLayoutGroup(Graphics willBeRenderedOn, List<LayoutEntry> contents, ref object crossGroupSharedData)
        {
            //Input (contents) is organized in lines. In most cases we are also working on lines, but not always, and even then, different lines. 
            //First step is to convert it to lines user sees, composed of displayblocks, itself composed of text and controls

            //List of all lines
            List<UserLine> userLines = new List<UserLine>(contents.Count);
            //Current working line
            UserLine currentUserLine = new UserLine();

            foreach (LayoutEntry layoutLine in contents)
            {

                string layoutString = layoutLine.LayoutString;

                ////below should never run, but prevents bad things happening if layoutLine has multiple {} in it
                //if (layoutString.IndexOf("{}", StringComparison.Ordinal) != layoutString.LastIndexOf("{}", StringComparison.Ordinal))
                //{
                //    Utils.BreakIfDebug();
                //    string[] parts = layoutString.Split(new[] {"{}"}, StringSplitOptions.None);

                //    layoutString = parts[0] + "{}" + string.Join(null, parts.Skip(1));

                //}
                //else if(!layoutString.Contains("{}"))
                //{

                //}

                int controls = 0;

                //HI THERE: IF YOUR STRING GETS INTERPRENTED WRONG THIS IS MOST LIKELY YOUR GOAT. IT IS PRIMITIVE!
                foreach (string alignmentPieces in layoutString.TrimEnd('\\', '/').Split(_split, StringSplitOptions.None))
                {
                    currentUserLine.DisplayBlocks.Add(
                        new DisplayBlock(
                            layoutStringTokenizer
                            .Split(alignmentPieces)
                            .Select(token => {
                                if (token == "{}")
                                {
                                    controls++;
                                    return new TextOrControl(layoutLine.GetRectangle(), layoutLine);
                                }
                                else
                                    return new TextOrControl(token, layoutLine);
                            })
                            .ToList()));
                }

                if(controls != 1)
                {
                    //TODO: Better handling non-one amount of {} which would be an error (obvious error message, ignored in tabulation sizes?
                    Log.Error($"Invalid or missing key for {layoutLine.OriginName}, it is required to contain exactly one {{}}, refer to chummer documentation on how to write DisplayStrings");

                }

                currentUserLine.DisplayBlocks.Last().AtomicParts.Last().EndOfToolTipHere = layoutLine.ToolTip;

                //Normaly we start a new line, but if string ends with \ we glue the next line on here
                if (!layoutLine.LayoutString.EndsWith("\\"))
                {
                    userLines.Add(currentUserLine);
                    currentUserLine = new UserLine();
                }
            }

            //We now have a load of lines. Goal is now to compute how large text on said lines is.
            //First step is to measure the size of all text


            //All strings we have seen
            HashSet<string> stringPieces = new HashSet<string>(userLines.SelectMany(x => x.DisplayBlocks).SelectMany(x => x.AtomicParts).Where(x => !x.IsControl).Select(x => x.Text));

            Dictionary<string, RectangleF> textSizes = ComputeTextSize(willBeRenderedOn, stringPieces.ToList());


            //We can now compute how big each displayblock is. Do this, and compute the size of the largest first block, second block, ect is
            //To ensure consistency over multiple groups, save it in crossGroupSharedData
            List<int> maxSizeOfBlockAtIndex = crossGroupSharedData as List<int> ?? new List<int>();

            foreach (UserLine line in userLines)
            {
                for (int i = 0; i < line.DisplayBlocks.Count; i++)
                {
                    int sizeOfDispayBlock = ComputeSizeOfDisplayBlock(textSizes, line.DisplayBlocks[i]);


                    if (maxSizeOfBlockAtIndex.Count > i)
                    {
                        maxSizeOfBlockAtIndex[i] = Math.Max(maxSizeOfBlockAtIndex[i], sizeOfDispayBlock);
                    }
                    else
                    {
                        maxSizeOfBlockAtIndex.Add(sizeOfDispayBlock);
                    }
                }
            }

            crossGroupSharedData = maxSizeOfBlockAtIndex;

            return new TabLayoutGroupComputation(userLines, maxSizeOfBlockAtIndex, textSizes);
        }

        public RenderedLayoutGroup RenderLayoutGroup(Graphics willBeRenderedOn, LayoutGroupComputation preComputedLayoutGroup,
            object crossGroupSharedData = null)
        {
            TabLayoutGroupComputation preComputed = preComputedLayoutGroup as TabLayoutGroupComputation;
            if(preComputed == null) throw new ArgumentException("preComputedLayoutGroup needs to have been provided by the same IGroupLayoutProvider and not be null");


            //Currently only tracking how big each displayBlock is. Now compute where each displayBlock will start
            int usedSize = 0;
            List<int> displayBlockStartAt = new List<int>(preComputed.MaxSizeOfBlockAtIndex.Count);
            foreach (int blockSize in preComputed.MaxSizeOfBlockAtIndex)
            {
                displayBlockStartAt.Add(usedSize);
                usedSize += blockSize;
            }

            var controlLocations = new List<RenderedLayoutGroup.GraphicRenderInfo>();
            var textLocations = new List<RenderedLayoutGroup.TextRenderInfo>();
            var toolTips = new List<RenderedLayoutGroup.ToolTipData>();

            int nextLineBeginsAt = 0;
            int toolTipBeginsAt = 0;
            foreach (UserLine userLine in preComputed.UserLines)
            {
                //if (userLine.DisplayBlocks.SelectMany(x => x.AtomicParts).Count(x => x.IsControl) > 1)
                //    Debugger.Break();
                
                int lineBottom = nextLineBeginsAt;
                for (int index = 0; index < userLine.DisplayBlocks.Count; index++)
                {
                    DisplayBlock displayBlock = userLine.DisplayBlocks[index];
                    int elementStartingPoint = displayBlockStartAt[index];
                    
                    foreach (TextOrControl textOrControl in displayBlock.AtomicParts)
                    {
                        if (textOrControl.IsControl)
                        {
                            Rectangle objPartRectangle = textOrControl.Control;
                            var location = new Point(
                                objPartRectangle.X + elementStartingPoint + LayoutOptions.ControlMargin,
                                objPartRectangle.Y + nextLineBeginsAt);  //TODO: This line probably lacks something, controls could once move up or down a little

                            controlLocations.Add(new RenderedLayoutGroup.GraphicRenderInfo
                            {
                                Location = location,
                                Source = textOrControl.OriginDisplayLine
                            });

                            elementStartingPoint += LayoutOptions.ControlMargin + objPartRectangle.Width;
                            lineBottom = Math.Max(lineBottom, nextLineBeginsAt + objPartRectangle.Height);
                        }
                        else
                        {
                            var size = ToSize(preComputed.StringPieces[textOrControl.Text]);
                            textLocations.Add(new RenderedLayoutGroup.TextRenderInfo
                            {
                                Text = textOrControl.Text,
                                Size = size,
                                Location = new Point(elementStartingPoint, nextLineBeginsAt),
                                Style = FontStyle.Regular //TODO: Does this get used? Do i want to support it?
                            });

                            elementStartingPoint += size.Width;
                            lineBottom = Math.Max(lineBottom, nextLineBeginsAt + size.Height);
                        }

                        if (textOrControl.EndOfToolTipHere != null)
                        {
                            toolTips.Add(
                                new RenderedLayoutGroup.ToolTipData(
                                    textOrControl.EndOfToolTipHere,
                                    new Rectangle(
                                        toolTipBeginsAt, 
                                        nextLineBeginsAt, 
                                        elementStartingPoint - toolTipBeginsAt,
                                        lineBottom - nextLineBeginsAt)));
                        }
                    }
                }

                nextLineBeginsAt = lineBottom + LayoutOptions.Linespacing;
            }
            

            return new RenderedLayoutGroup()
            {
                ControlLocations = controlLocations,
                TextLocations = textLocations,
                ToolTips = toolTips,
                Width = usedSize,
                Height = nextLineBeginsAt,
            }; 
        }

        //The graphics object will at max accept a batchsize of 32 or it will crap itself
        private const int BATCH_SIZE = 32;
        Dictionary<string, RectangleF> ComputeTextSize(Graphics graphics, List<string> lines)
        {
            //TODO: Might be able to make this global, and this part is slowish
            //Compute text size of every line
            //It might be possible to do this in a better(faster while still accurate) way, but we ask the Graphics object how large strings will be

            //Only hazzle is the Graphics object is slow.
            //We try to do it faster by batching (Nobody actually measured if batching is faster....)
            //But the graphics object will at max accept a batchsize of 32 or it will crap itself

            //So the following code is just an elaborate way of calling Graphics.MeasureText in big chunks
            int intLineCount = lines.Count;
            Dictionary<string, RectangleF> resultDictionary = new Dictionary<string, RectangleF>(intLineCount);
            CharacterRange[] ranges = new CharacterRange[Math.Min(BATCH_SIZE, intLineCount)];
            var format = new StringFormat();

            for (int start = 0; start < intLineCount; start += BATCH_SIZE)
            {
                int end = Math.Min(intLineCount, start + BATCH_SIZE);

                //Optimization, compute lenght of strings that will be added
                StringBuilder combinedText = new StringBuilder();

                for (int i = start; i < end; i++)
                {
                    string line = lines[i];
                    ranges[i-start] = new CharacterRange(combinedText.Length, line.Length);
                    combinedText.AppendLine(line);
                }
                combinedText.Length--; //Remove last newline

                // The last batch of a set may be smaller than 32, in which case we need to return a smaller array than the one we've been using
                int intRangeSize = end - start;
                if (intRangeSize < ranges.Length)
                {
                    CharacterRange[] objLastRanges = new CharacterRange[intRangeSize];
                    for (int i = 0; i < intRangeSize; i++)
                    {
                        objLastRanges[i] = ranges[i];
                    }
                    format.SetMeasurableCharacterRanges(objLastRanges);
                }
                else
                    format.SetMeasurableCharacterRanges(ranges);
                Region[] regions = graphics.MeasureCharacterRanges(
                    combinedText.ToString(), 
                    LayoutOptions.Font,
                    new RectangleF(0, 0, float.MaxValue, float.MaxValue), 
                    format);

                for (int i = start; i < end; i++)
                {
                    string line = lines[i];
                    Region region = regions[i - start];
                    resultDictionary.Add(line, region.GetBounds(graphics));
                }
            }

            return resultDictionary;
        }

        int ComputeSizeOfDisplayBlock(Dictionary<string, RectangleF> testSizes, DisplayBlock displayBlock)
        {
            int sizeSoFar = 0;
            foreach (TextOrControl atomicPart in displayBlock.AtomicParts)
            {
                if (atomicPart.IsControl)
                {
                    int controlSize = atomicPart.Control.Width + (LayoutOptions.ControlMargin * 2);
                    sizeSoFar += controlSize;
                }
                else
                {
                    sizeSoFar += (int) Math.Ceiling(testSizes[atomicPart.Text].Width);
                }
            }
            return sizeSoFar;
        }

        //The layout procedure is rather simple (in theory).  It interprents multiple \t inside text and makes sure every
        //tab accros multiple lines share same end
        //Basically the same as normal text tab, but instead of having a defined lenght in spaces, it findes
        //the minimum possible accross all, without exeeding it
        //In other words, after every \t the next following character will align on all lines

        /// <summary>
        /// Various tweakable settings that can be changed
        /// </summary>
        public LayoutOptionsContainer LayoutOptions { get; set; } = new LayoutOptionsContainer();

        private static Size ToSize(RectangleF getBounds)
        {
            //Console.WriteLine("Rectangle of {0} {1}", getBounds.Width, getBounds.Height);
            return new Size((int) getBounds.Width, (int) getBounds.Height);
        }
    }
}
