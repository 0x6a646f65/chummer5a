using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using Point = System.Drawing.Point;

namespace Chummer.Backend.Options
{
    /*
     * This class contains the logic used (at time of writing) for basic layout of (everything) when autogenerating
     * interfaces. (Only used by options at time of writing). This contains the layouting part of autogenerated interfaces.
     * It cooperates with OptionRender.cs to do the actual rendering (well, adding stuff to a control)
     * I'm not very versed in WPF, but it _should_ work with anything with uniform text size.
     *
     * It is named as so, because it provides layout, it uses tab to align stuff and thats it. Anybody feel free to refactor to a better name.
     * As it is still under development, it contains quite a few debug statements. Those _should_ be removed before release
     */
    public class TabAlignmentGroupLayoutProvider : IGroupLayoutProvider
    {
        /// <summary>
        /// Various tweakable settings that can be changed
        /// </summary>
        public LayoutOptionsContainer LayoutOptions { get; set; } = new LayoutOptionsContainer();

        /// <summary>
        /// Transforms a list of LayoutLineInfo that contains a size of a control element and supporting text into a
        /// list of positions for the control elements and strings and positions for labels.
        /// Supporting text can be broken down into smaller labels to make space for control elements inside the text,
        /// or to align with other parts
        /// </summary>
        /// <param name="contents"></param>
        /// <returns></returns>
        public LayoutRenderInfo PerformLayout(List<LayoutLineInfo> contents)
        {
            //Create the container with all return information
            LayoutRenderInfo ret = new LayoutRenderInfo(){ControlLocations = new List<Point>(), TextLocations = new List<TextRenderInfo>()};

            //The layout procedure is rather simple. It interprents multiple \t inside text and makes sure every
            //tab accros multiple lines share same end
            //Basically the same as normal text tab, but instead of having a defined lenght in spaces, it findes
            //the minimum possible accross all, without exeeding it
            //In other words, after every \t the next following character will align on all lines

            //Keeps the mimumum size required for each tab.
            List<int> alignmentLenghts = new List<int>();
            //Loop over every line in the layout and calculate how big elements need to be
            foreach (LayoutLineInfo line in contents)
            {
                string[] alignmentPieces = line.LayoutString.Split(new []{"\\t"}, StringSplitOptions.None);
                Console.WriteLine($"splitting {line.LayoutString} into [{string.Join(", ", alignmentPieces)}]");

                //For every aligntment piece (piece of text with \t before/after) find out how large it needs to be
                //If a previous size requirement for that tab count is already found, take the biggest one
                //Otherwise store a new one
                for (int i = 0; i < alignmentPieces.Length-1; i++)
                {
                    Console.WriteLine("Processing {0}", alignmentPieces[i]);
                    if (alignmentLenghts.Count > i)
                    {

                        alignmentLenghts[i] = Math.Max(
                            alignmentLenghts[i],
                            ElementSize(alignmentPieces[i], line.ControlSize, line.ControlOffset).Width);
                    }
                    else
                    {
                        Console.WriteLine($"Creating new align on \"{alignmentPieces[i]}\"{i}");
                        alignmentLenghts.Add(ElementSize(alignmentPieces[i], line.ControlSize, line.ControlOffset).Width);
                    }
                }
            }

            //After previous loop alignmentLenghts contain the the size of each group.
            //The following lines convert this to pixel offsets for each group

            //First group should start at 0, not reservering a free space to house a duplicate for first group.
            alignmentLenghts.Insert(0,0);
            Console.WriteLine(string.Join(", ", alignmentLenghts));

            //Then add the sum of all prievious elements to all elements, convering lenghts to starting indexes
            for (int i = 1; i < alignmentLenghts.Count; i++)
            {
                alignmentLenghts[i] += alignmentLenghts[i - 1];
                Console.WriteLine($"[{i}] <- {alignmentLenghts[i]} added {alignmentLenghts[i - 1]}");
            }

            //LineTop defines the top of the current line, lineButtom keeps track of how far down it goes
            int lineTop = 0;
            int lineBottom = 0;

            //Perform the actual layout
            foreach (LayoutLineInfo line in contents)
            {
                bool drewControl = false;
                //How many pixels is already used
                int lineRight = 0;

                //To perform the alignment, every aligntment piece gets its own text label. Calculate the position of those now
                string[] alignmentPieces = line.LayoutString.Split(new []{"\\t"}, StringSplitOptions.None);
                for (int i = 0; i < alignmentPieces.Length; i++)
                {
                    //{} is to be substituded with a control, to display those inline.
                    if (!drewControl && alignmentPieces[i].Contains("{}"))
                    {
                        //As the string has a control inside, we need 2 labels surounding it

                        //calculate the size of the 2 surounding text elements


                        string[] sides = alignmentPieces[i].Split(split, 2, StringSplitOptions.None);
                        Size size = ElementSize(sides[0], Size.Empty, Point.Empty);
                        Size size2 = ElementSize(sides[1], Size.Empty, Point.Empty);

                        Console.WriteLine($"text left = {alignmentLenghts[i]} + {size.Width} + {line.ControlSize.Width} + {LayoutOptions.ControlMargin} * 2");

                        //Add the labels. Second calculating involes control size & margin, making it slightly more wonky
                        ret.TextLocations.Add(new TextRenderInfo{Location = new Point(alignmentLenghts[i], lineTop), Size = size, Text = sides[0]});
                        ret.TextLocations.Add(new TextRenderInfo
                        {
                            Location =
                                new Point(
                                    alignmentLenghts[i] + size.Width + line.ControlSize.Width +
                                    LayoutOptions.ControlMargin * 2, lineTop),
                            Size = size2,
                            Text = sides[1]
                        });

                        //Also save where the control is supposed to be stored
                        ret.ControlLocations.Add(new Point(alignmentLenghts[i] + size.Width + LayoutOptions.ControlMargin, lineTop + line.ControlOffset.Y));
                        Console.WriteLine($"c = {alignmentLenghts[i]} + {size.Width} + {LayoutOptions.ControlMargin}");

                        //Find what was biggest and record height
                        lineBottom = Math.Max(lineBottom, lineTop + Math.Max(size.Height, line.ControlSize.Height - Math.Min(0, line.ControlOffset.Y)));
                        drewControl = true;
                    }
                    else
                    {
                        //No control included makes it simple. Calculate size, add it and advance size counter
                        Size size = ElementSize(alignmentPieces[i], Size.Empty, Point.Empty);
                        TextRenderInfo tri = new TextRenderInfo
                        {
                            Location = new Point(alignmentLenghts[i], lineTop),
                            Size = size,
                            Text = alignmentPieces[i]
                        };
                        Console.WriteLine($"Rendering tri \"{tri.Text}\" at {tri.Location.X},{tri.Location.Y} ({tri.Size.Width},{tri.Size.Height})");
                        ret.TextLocations.Add(tri);
                        lineBottom = Math.Max(lineBottom, lineTop + size.Height);

                        lineRight = alignmentLenghts[i] + size.Width;
                    }
                }

                //If control was not added, add it last in the line. This is the only case lineRight is acctually read
                //If we could trust strings we could skip much of this, but crashing due a bad string is bad.
                if(drewControl == false)
                {
                    ret.ControlLocations.Add(new Point(lineRight + LayoutOptions.ControlMargin, lineTop + line.ControlOffset.Y));
                    lineBottom = Math.Max(lineBottom, lineTop + line.ControlSize.Height - Math.Min(0, line.ControlOffset.Y));
                }

                lineTop = lineBottom + LayoutOptions.Linespacing;
            }

            return ret;
        }

        private string[] split = new[] {"{}"};
        private Size ElementSize(string textMaybeEmbeddedControl, Size controlSize, Point controlOffset)
        {
            //Either calculate the size of text, or black magic to calculate the size of control and 2 pieces of text to suround it
            if (textMaybeEmbeddedControl.Contains("{}"))
            {
                string[] sides = textMaybeEmbeddedControl.Split(split, 2, StringSplitOptions.None);

                Size s1, s2;
                s1 = TextRenderer.MeasureText(sides[0], Control.DefaultFont);
                s2 = TextRenderer.MeasureText(sides[1], Control.DefaultFont);

                //TODO: this should be how far the total element goes outside the upper left cornor of the text. Any that the control goes over should be ignored.
                //Probably confused because i don't quite see what controlOffset.X means
                int height = Math.Max(s1.Height, controlSize.Height - Math.Min(0, controlOffset.Y));
                int width = controlSize.Width + s1.Width + s2.Width; //Probably sane way
                Console.WriteLine($"Calculated width = {width} from {controlSize.Width} +{s1.Width} + {s2.Width} \"{textMaybeEmbeddedControl}\"");
                return new Size(width /*-5*/, height);
            }
            else
            {
                Size s = TextRenderer.MeasureText(textMaybeEmbeddedControl, Control.DefaultFont);
                //s.Width -= 5;
                return s;
            }
        }

        public class LayoutOptionsContainer
        {
            public int Linespacing { get; set; } = 6;
            public int ControlMargin { get; set; } = 3;
        }
    }
}